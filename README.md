# BHS2025_GUITestTask
Test task for BHS for the position "GUI programmer"

# Задание 1

Сделано с использованием WPF.

![image](https://github.com/user-attachments/assets/12295deb-930c-4c3f-aab4-20c841ec9ab5)

# Задание 2

* В RegisterPassenger: _currentNumber++ не атомарен -> Можно использовать Interlocked.Increment - делает инкримент по указанной переменной и сохраняет результат в качестве атомика (атомарной операции). ConcurrentDictionary.TryAdd() предпочтительнее прямого присваивания, чтобы избежать коллизий.
* Ошибка в статическом методе GetAllPassengersNames. Метод static, но обращается к нестатическому полю Passengers. Надо убрать статик и будет хорошо.
* В блоке catch вызывается Monitor.Exit, но если исключение произойдет до Monitor.Enter, это вызовет ошибку. Можно добавить ```finally { Monitor.Exit(_sync); }``` для гарантированного освобождения. Или можно на семафор с асинхронным ожиданием заменить.
* Поля PlaceService, SailDb, PassengersDb инициализируются через единственный (как-то он там в шарпах называется еще) конструктор, но могут быть null (потом по коду проверок на налл нет). Проверка на конструктор ```PlaceService = placeService ?? throw new ArgumentNullException(nameof(placeService));```
* Свойство Passengers имеет публичный сеттер, что нарушает инкапсуляцию. Делаем сеттер приватным, а лучше на IReadOnlyDictionary.
* Неиспользуемый параметр doc в ChangeCaptain
* За async void минус карма. Меняем на async Task, чтобы обрабатывать исключения корректно.
* В конкатенации строк в GetAllPassengersNames лучше использовать StringBuilder вместо конкатенации в цикле для оптимизации производительности.
* Сравнение coordinate.Equals(tmp) может привести к NullReferenceException, если coordinate не инициализирован. long.Parse(coord) заменить на long.TryParse(coord)
* Класс Person имеет публичные сеттеры. Делать свойства лучше инициализируемыми только через конструктор (immutable)
* Про SetSail: если SailDb.Save и PassengersDb.Save должны выполняться атомарно, то лучше обернуть их в транзакцию надо. Не забыть про обработку исключений (трай кеч), в Java есть удобный трай-виз-ресурсес, логов добавить можно еще.
* JsonConvert.SerializeObject(Passengers) может быть медленным для больших коллекций. Следует сериализовать только значения.
* А где документация)


# Задание 3

1) Для этого есть System.Collections.Generic.List[T].AddRange
2) Тут при расширении массива внутри списка будет происходить копирование этого массива, что нехорошо
Лучше выделить массив сразу нужного размера

```var result = new List<T>(hashSet.Count);```

3) Можно пойти на хитрость и сделать ленивый прокси-список, который внутри хранит ссылку на этот хешсет. Если только итерируемся, то будет нормально, а когда начинаем что-то индексозависимое делать, то только тогда копируем, а ссылку на хеш сет обнуляем, чтобы его сборщик мусора съел
